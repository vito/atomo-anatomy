-- accessor for the toplevel scope
indent-level = Parameter new: 0
multiline-pretty? = Parameter new: False
docs-root = Parameter new: ""

A bold: s := s in-tag: "strong"
A italic: s := s in-tag: "em"

(a: A) atomo: (e: Expression) :=
    "<code>" .. (a pretty: e) .. "</code>"

(a: A) atomo-block: (e: Expression) :=
    "<pre class=\"verbatim\">" .. (a pretty: e) .. "</pre>"

(s: String) operator? :=
    s all?: { c | "~!@#$%^&*-_=+./\\|<>?:" contains?: c }

(s: String) type: (c: String) :=
    "<span class=\"" .. c .. "\">" .. s .. "</span>"

(s: String) escape :=
    s match: {
        [] -> ""
        '<' . ss -> "&lt;" .. ss escape
        '>' . ss -> "&gt;" .. ss escape
        '&' . ss -> "&amp;" .. ss escape
        s . ss -> [s] .. ss escape
    }

A pretty: o := o show escape
A pretty: (c: Char) := c show type: "char"
A pretty: (d: Double) := d show type: "number double"
A pretty: (i: Integer) := i show type: "number integer"
A pretty: (p: Pattern) := p show (drop: "<pattern " length) init escape type: "pattern"

pretty-particle = { a p |
    if: p values (all?: @(== @none))
        then: { ("@" .. p names (map: { n | n keywordfy escape (type: "names") }) concat) type: "particle" }
        else: {
            initial =
                p values head match: {
                    @none -> ""
                    @(ok: v) -> a pretty: v
                }

            ks = (0 ... p names length) map: { n |
                name = p names (at: n)
                value =
                    p values (at: n + 1) match: {
                        @none -> "_"
                        @(ok: v) -> a pretty: v
                    }

                name keywordfy escape (type: "names") .. " " .. value
            }

            ("@(" .. initial .. ks (join: " ") .. ")") type: "particle"
        }
}

(a: A) pretty: (p: Particle) :=
    p type match: {
        @single -> ("@" .. p name escape (type: "name")) type: "particle"
        @keyword ->
            pretty-particle call: [a, p]
    }

(a: A) pretty: (l: List) :=
    if: (l all?: @(is-a?: Char))
        then: { l show escape type: "string" }
        else: { ("[" .. l (map: { l | a pretty: l }) (join: ", ") .. "]") type: "list" }

(a: A) pretty: (b: Block) := {
    indent = indent-level _? + 1
    indent-level =! indent

    arguments = b arguments (map: { p | a pretty: p }) (join: " ")

    pretty-contents = b contents (map: { e | a pretty: e })
    contents =
        if: multiline-pretty? _?
            then: {
                exprs = pretty-contents (map: { c |
                    "\n" .. (' ' replicate: (indent * 2)) .. c
                }) concat

                exprs .. "\n" .. (' ' replicate: ((indent - 1) * 2))
            }
            else: { " " .. pretty-contents (join: "; ") .. " " }
    
    indent-level =! indent - 1

    if: contents empty?
        then: { "{}" type: "block" }
        else: {
            if: b arguments empty?
                then: { ("{" .. contents .. "}") type: "block" }
                else: { ("{ " .. arguments .. " |" .. contents .. "}") type: "block" }
        }
} call

(a: A) pretty: (e: Expression) := a pretty: e context: @top

(a: A) pretty: (e: Expression) context: c := {
    current-output-port = Port standard-output

    e type match: {
        @dispatch -> {
            url = a url-for: e
            linked = { text |
                n = text escape type: "dispatch single"
                url match: {
                    @none -> n
                    @(ok: u) ->
                        ("<a href=\"" .. docs-root _? .. u .. "\">" .. n .. "</a>")
                }
            }

            e dispatch-type match: {
                @single -> {
                    msg = linked call: [e particle name]

                    if: (e target type == @top)
                        then: { msg }
                        else: { (a pretty: e target context: @single) .. " " .. msg }
                } call

                @keyword -> {
                    initial =
                        if: (e targets head type == @top)
                            then: { "" }
                            else: { (a pretty: e targets head context: @keyword) .. " " }

                    rest =
                        if: e targets (map: @type) (all?: @(== @top))
                            then: { linked call: [e particle names (map: @keywordfy) concat] }
                            else: {
                                ks = (0 ... e particle names length) map: { n |
                                    name = e particle names (at: n)
                                    value = a pretty: e targets (at: n + 1) context: @keyword

                                    (linked call: [name keywordfy]) .. " " .. value
                                }

                                ks join: " "
                            }

                    if: (c == @single || c == @keyword)
                        then: { "(" .. initial .. rest .. ")" }
                        else: { initial .. rest }
                } call
            }
        } call

        @define ->
            (a pretty: e pattern) .. " := " .. (a pretty: e expression)
        @set ->
            (a pretty: e pattern) .. " = " .. (a pretty: e expression)

        @list ->
            (if: (e contents all?: { e | e type == @primitive })
                then: { a pretty: e evaluate }
                else: { "[" .. e contents (map: { l | a pretty: l }) (join: ", ") .. "]" })

        @particle ->
            e particle-type match: {
                @single -> a pretty: e evaluate
                @keyword -> pretty-particle call: [a, e]
            }

        @primitive -> a pretty: e evaluate
        @block -> a pretty: e evaluate

        @call -> ("<span style=\"font-weight: bold\">dispatch</span>")

        x -> e show escape
    }
} call

(s: String) keywordfy :=
    if: s operator?
        then: { s }
        else: { s .. ":" }

get-fake-output := {
    current-output-port _? close

    (Port new: "fake-output" mode: @read) ensuring: { in |
        in close
        current-output-port set-default: (Port new: "fake-output" mode: @write)
    } do: { in |
        if: in eof? not
            then: {
                with-input-from: in do: {
                    out = ""

                    while: { in eof? not } do: {
                        out = out .. read-line .. "\n"
                    }

                    out escape
                }
            }
            else: { "" }
    }
} call

(a: A) interaction: (e: Expression) :=
    a interaction: e evaluate on: Object clone
(a: A) interaction: (b: Block) :=
    a interaction: b on: Object clone

(a: A) interaction: (e: Expression) on: (t: Expression) :=
    a interaction: e evaluate on: (dispatch sender join: (Block new: [t]))
(a: A) interaction: (b: Block) on: env := {
    "interaction" print
    b print
    log = with-output-to: "fake-output" do: {
        b contents (map: { e |
            res = env join: (Block new: [e])
            "&gt; " .. (a pretty: e) .. "\n" .. get-fake-output .. (a pretty: res) .. "\n"
        }) concat
    }

    File delete: "fake-output"

    "<pre class=\"interaction\">" .. log .. "</pre>"
} call

(a: A) example: (e: Expression) :=
    "<div class=\"example\"><em>Example:</em>" .. (a interaction: e) .. "</div>"

(a: A) link: name to: (url: Expression) := a link: name to: url evaluate
(a: A) link: (name: Expression) to: url := a link: name evaluate to: url
A link: (name: String) to: (url: String) :=
    "<a href=\"" .. url .. "\">" .. name .. "</a>"

A verbatim: (s: String) :=
    "<pre class=\"verbatim\">" .. s escape .. "</pre>"

A code: (s: String) := s escape in-tag: "code"

(e: Expression) in-tag: t := e evaluate (as: String) in-tag: t
(s: String) in-tag: t := "<" .. t .. ">" .. s .. "</" .. t .. ">"
