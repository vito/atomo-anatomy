-- accessor for the toplevel scope
indent-level = Parameter new: 0
multiline-pretty? = Parameter new: False
docs-root = Parameter new: ""
value-output? = Parameter new: False

A bold: s := s in-tag: "strong"
A italic: s := s in-tag: "em"

(a: A) atomo: (e: Expression) :=
    "<code>" .. (a pretty: e) .. "</code>"

(a: A) atomo-block: (e: Expression) :=
    "<pre class=\"verbatim\">" .. (a pretty: e) .. "</pre>"

(s: String) operator? :=
    s all?: { c | "~!@#$%^&*-_=+./\\|<>?:" contains?: c }

(s: String) type: (c: String) :=
    "<span class=\"" .. c .. "\">" .. s .. "</span>"

(s: String) escape :=
    s match: {
        "" -> ""
        '<' . ss -> "&lt;" .. ss escape
        '>' . ss -> "&gt;" .. ss escape
        '&' . ss -> "&amp;" .. ss escape
        s . ss -> s . ss escape
    }

A pretty: o := {
    s = o show

    if: (s starts-with?: "<")
        then: { s escape type: "internal" }
        else: { s escape }
} call

A pretty: (c: Char) := c show type: "char"
A pretty: (d: Double) := d show type: "number double"
A pretty: (i: Integer) := i show type: "number integer"
A pretty: (p: Pattern) :=
    if: value-output? _?
        then: { p show escape type: "internal" }
        else: { p show (drop: "<pattern " length) init escape type: "pattern" }
A pretty: (c: String) := c show escape type: "string"

pretty-particle = { a p |
    if: p values (all?: @(== @none))
        then: { ("@" .. p names (map: { n | n keywordfy escape (type: "names") }) join) type: "particle" }
        else: {
            initial =
                p values head match: {
                    @none -> ""
                    @(ok: v) -> a pretty: v
                }

            ks = (0 ... p names length) map: { n |
                name = p names (at: n)
                value =
                    p values (at: (n + 1)) match: {
                        @none -> "_"
                        @(ok: v) -> a pretty: v
                    }

                name keywordfy escape (type: "names") .. " " .. value
            }

            ("@(" .. initial .. ks (join: " ") .. ")") type: "particle"
        }
}

(a: A) pretty: (p: Particle) :=
    p type match: {
        @single -> ("@" .. p name escape (type: "name")) type: "particle"
        @keyword ->
            pretty-particle call: [a, p]
    }

(a: A) pretty: (l: List) :=
    ("[" .. l (map: { l | a pretty: l }) (join: ", ") .. "]") type: "list"

(a: A) pretty: (b: Block) := with: value-output? as: False do: {
    indent = indent-level _? + 1
    indent-level =! indent

    arguments = b arguments (map: { p | a pretty: p }) (join: " ")

    pretty-contents = b contents (map: { e | a pretty: e })
    contents =
        if: multiline-pretty? _?
            then: {
                exprs = pretty-contents (map: { c |
                    "\n" .. (' ' repeat: (indent * 2)) .. c
                }) join

                exprs .. "\n" .. (' ' repeat: ((indent - 1) * 2))
            }
            else: { " " .. pretty-contents (join: "; ") .. " " }
    
    indent-level =! indent - 1

    if: contents strip empty?
        then: { "{}" type: "block" }
        else: {
            if: b arguments empty?
                then: { ("{" .. contents .. "}") type: "block" }
                else: { ("{ " .. arguments .. " |" .. contents .. "}") type: "block" }
        }
}

(a: A) pretty: (e: Expression) := a pretty: e context: @top
(a: A) pretty: (e: Expression) context: c := {
    current-output-port = Port standard-output

    pretty = e type match: {
        @dispatch -> with: value-output? as: False do: {
            url = a url-for: e
            linked = { text |
                n = text escape type: "dispatch single"
                url match: {
                    @none -> n
                    @(ok: u) ->
                        ("<a href=\"" .. docs-root _? .. u .. "\">" .. n .. "</a>")
                }
            }

            e dispatch-type match: {
                @single -> {
                    msg = linked call: [e particle name]

                    if: (e target type == @top)
                        then: { msg }
                        else: { (a pretty: e target context: @single) .. " " .. msg }
                } call

                @keyword -> {
                    initial =
                        if: (e targets head type == @top)
                            then: { "" }
                            else: { (a pretty: e targets head context: @keyword) .. " " }

                    rest =
                        if: e targets (map: @type) (all?: @(== @top))
                            then: { linked call: [e particle names (map: @keywordfy) join] }
                            else: {
                                ks = (0 ... e particle names length) map: { n |
                                    name = e particle names (at: n)
                                    value = a pretty: e targets (at: (n + 1)) context: @keyword

                                    (linked call: [name keywordfy]) .. " " .. value
                                }

                                ks join: " "
                            }

                    if: (c == @single || c == @keyword)
                        then: { "(" .. initial .. rest .. ")" }
                        else: { initial .. rest }
                } call
            }
        }

        @define -> with: value-output? as: False do: {
            pat = a pretty: e pattern

            if: multiline-pretty? _?
                then: {
                    indent = indent-level _? + 1
                    expr = with: indent-level as: indent do: {
                        a pretty: e expression context: @define
                    }

                    pat .. " :=\n" .. (' ' repeat: (indent * 2)) .. expr .. "\n"
                }
                else: {
                    expr = a pretty: e expression context: @define
                    pat .. " := " .. expr
                }
        }

        @set -> with: value-output? as: False do: {
            (a pretty: e pattern) .. " = " .. (a pretty: e expression context: @set)
        }

        @list ->
            if: (e contents all?: { e | e type == @primitive })
                then: { a pretty: e evaluate }
                else: { "[" .. e contents (map: { l | a pretty: l context: @list }) (join: ", ") .. "]" }

        @particle ->
            e particle-type match: {
                @single -> a pretty: e evaluate
                @keyword -> pretty-particle call: [a, e]
            }

        @primitive -> a pretty: e evaluate

        @block -> a pretty: e evaluate

        @call -> "dispatch" type: "call"

        x -> e show escape
    }

    if: value-output? _?
        then: { ("<expression " escape .. pretty .. ">" escape) type: "internal" }
        else: { pretty }
} call

(s: String) keywordfy :=
    if: s operator?
        then: { s }
        else: { s .. ":" }

get-fake-output := File read: "fake-output"

(a: A) interaction: (e: Expression) :=
    a interaction: e evaluate on: Object clone
(a: A) interaction: (b: Block) :=
    a interaction: b on: Object clone

(a: A) interaction: (e: Expression) on: (t: Expression) :=
    a interaction: e evaluate on: (dispatch sender join: (Block new: [t]))
(a: A) interaction: (b: Block) on: env := {
    "interaction" print
    b print
    log =  b contents (map: { e |
        {
            res = with: value-output? as: True do: {
                with-all-output-to: "fake-output" do: {
                    a pretty: (env join: (Block new: [e]))
                }
            }

            "&gt;" (type: "caret") .. " " .. (a pretty: e) .. "\n" .. get-fake-output .. res .. "\n"
        } ensuring: {
            when: File (exists?: "fake-output")
                do: { File delete: "fake-output" }
        }
    }) join

    "<pre class=\"interaction\">" .. log .. "</pre>"
} call

(a: A) example: (e: Expression) :=
    "<div class=\"example\"><em>Example:</em>" .. (a interaction: e) .. "</div>"

(a: A) link: name to: (url: Expression) := a link: name to: url evaluate
(a: A) link: (name: Expression) to: url := a link: name evaluate to: url
A link: (name: String) to: (url: String) :=
    "<a href=\"" .. url .. "\">" .. name .. "</a>"

A verbatim: (s: String) :=
    "<pre class=\"verbatim\">" .. s escape .. "</pre>"

A code: (s: String) := s escape in-tag: "code"

(e: Expression) in-tag: t := e evaluate (as: String) in-tag: t
(s: String) in-tag: t := "<" .. t .. ">" .. s .. "</" .. t .. ">"
