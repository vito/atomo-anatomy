require: "pretty.atomo"
require: "util.atomo"

-- various semantic helpers
A bold: s := s in-tag: "strong"
A italic: s := s in-tag: "em"
A code: (s: String) := s escape in-tag: "code"
A list: s := s in-tag: "ul"
A numbered-list: s := s in-tag: "ol"
A item: s := s in-tag: "li"
A definitions: s := s in-tag: "dl"
A item: s is: v := (s in-tag: "dt") .. (v in-tag: "dd")
A verbatim: (s: String) :=
  s escape in-tag: "pre class=\"verbatim\""

-- external link
(a: A) link: name to: (url: Expression) := a link: name to: url evaluate
(a: A) link: (name: Expression) to: url := a link: name evaluate to: url
A link: (name: String) to: (url: String) :=
  name in-tag: ("a href=\"" .. url .. "\" class=\"external\"")

-- pretty-printing a single expr, inline
(a: A) atomo: (e: Expression) :=
  (a pretty: e) in-tag: "code"

-- pretty-printing a single expr, block
(a: A) atomo-line: (e: Expression) :=
  (a pretty: e) in-tag: "pre class=\"verbatim\""

-- pretty-print a block of expressions
(a: A) atomo-segment: (e: Expression) :=
  e evaluate contents (map: { c | a pretty: c }) (join: "\n")
    in-tag: "pre class=\"verbatim\""

-- example code (unevaluated)
(a: A) example-segment: (e: Expression) :=
  ("<em>Example:</em>" .. (a atomo-segment: e))
    in-tag: "div class=\"example\""

-- pretty-print a block of Atomo code, multiline
(a: A) atomo-block: (e: Expression) :=
  with: multiline-pretty? as: True do: {
    a atomo-line: e
  }

-- example interaction session
(a: A) example: (e: Expression) :=
  ("<em>Example:</em>" .. (a interaction: e))
    in-tag: "div class=\"example\""

-- a REPL simulator
(a: A) interaction: (e: Expression) :=
  a interaction: e evaluate on: Object clone
(a: A) interaction: (b: Block) :=
  a interaction: b on: Object clone

-- a REPL simulator locked into an environment
(a: A) interaction: (e: Expression) on: (t: Expression) :=
  a interaction: e evaluate on: (t evaluate-in: sender)
(a: A) interaction: (b: Block) on: env :=
  { ("interaction: " .. b show) print

    log =  b contents (map: { e |
      { res = {
          with: value-output? as: True do: {
            with-all-output-to: "fake-output" do: {
              a pretty: (env join: (Block new: [e expand]))
            }
          }
        } catch: { e |
          (a pretty: e) type: "error"
        }

        [
          "&gt;" type: "caret"
          " "
          a pretty: e
          "\n"
          File (read: "fake-output") escape
          res
          "\n"
        ] join
      } ensuring: {
        when: File (exists?: "fake-output")
          do: { File delete: "fake-output" }
      }
    }) join

    log in-tag: "pre class=\"interaction\""
  } call
